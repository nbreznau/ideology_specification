---
title: "03 Data Viz"
output: html_notebook
---
Replication workflow for:

"Ideological Bias in Estimates of the Impact of Immigration"

[George J. Borjas](https://www.hks.harvard.edu/faculty/george-borjas) <br>
[Nate Brezau](https://sites.google.com/site/nbreznau/) <br>

The original workflow was developed by Borjas using Stata (see `reg_model.do` in this repository), and this workflow is an identical set of analyses by Breznau done in R. 

The file `df.rds` (also available as csv) was generated in the file `01_Data_Prep.Rmd`.

## Setup

```{r setup}

packages <- c("tidyverse",
              "knitr",
              "pacman",
              "here",
              "ragg",
              "margins",
              "miceadds",
              "ggplot2",
              "viridis",
              "ggridges",
              "haven",
              "broom",
              "lm.beta",
              "scales")

pacman::p_load(packages, character.only = T)

# palette
colors <- c("#453781FF", "#3CBB75FF", "#FD9567FF")

```


## Data

```{r data}

df <- read_rds(here("data", "df.rds")) %>%
  mutate(index1 = group1,
         index2 = ifelse(group1 == 0 & group3 == 0, 1, 0),
         index3 = group3)
df_dyad <- read_csv(here("data", "df_dyad.csv"))

# regression results from 02_Tables.Rmd
load(here("results", "reg_results.Rdata"))

Table_1_model <- read_rds(here("results", "Table_1_model.rds"))

```

## Reg Models

Certain routines require non lm.cluster objects. Predicted values are identical so it is easier to work with lm objects.

```{r regs}

# add single weight variable, it is easier
df <- df %>%
  mutate(mweight = 1/nmodel,
         peerweight = pscore_1/nmodel)

# we scale up pweight slightly to arrive at 71 teams, some cases from df get dropped to dyads due to missing info

df_dyad <- df_dyad %>%
  mutate(mweight = pweight*1.019,
         peerweight = pscore_1*(pweight*1.019))

m_1lm <- lm(formula=AME ~ group3 + stats_brw + topic_brw + t2 + t3 + factor(mdegree), weights = df$mweight, data = df)

m_3lm <- lm(formula=AME ~ group1 + group3 + stats_brw + topic_brw + t2 + t3 + factor(mdegree), weights = df$mweight, data = df)

p_1lm <- lm(formula=AME ~ group3 + stats_brw + topic_brw + t2 + t3 + factor(mdegree), weights = df$peerweight, data = df)

p_3lm <- lm(formula=AME ~ group1 + group3 + stats_brw + topic_brw + t2 + t3 + factor(mdegree), weights = df$peerweight, data = df)

# Dyad level

m_3dlm <- lm(formula=AME ~ indiv1 + indiv3 + stats_i + topic_i + t2 + t3 + factor(backgr_degree), weights = df_dyad$pweight,data = df_dyad)

p_3dlm <- lm(formula=AME ~ indiv1 + indiv3 + stats_i + topic_i + t2 + t3 + factor(backgr_degree), weights = df_dyad$pweight*df_dyad$peerweight, data = df_dyad)
```

## Fig1A

```{r fig1}
# Proportion of dots with specific colors


# Create a data frame with the points and colors
df_sphere <- data.frame(
  x = c(1.22,1.32,1.42),
  y = c(8.2,8.8,8.2),
  color = colors
)

Table_1_model[3:4, 2:5] <- lapply(Table_1_model[3:4, 2:5], function(x) {
  # Convert to numeric if it's not already
  x <- as.numeric(as.character(x))
  # Format as percentage with 1 decimal place, even if it's .0
  paste0(format(x * 100, nsmall = 1), "%")
})



# positions for plotting
x_positions <- c(4, 4.8, 5.75, 6.6)
y_pos1 <- c(1, 1, 1)
y_pos2 <- c(2, 2, 2)
y_pos3 <- c(3, 3, 3)
y_pos4 <- c(4, 4, 4)
```


```{r fig1p}
agg_png(here("results", "Fig1A.png"), res = 144, height = 500, width = 800)

f1a <- ggplot() +
  # Set x-axis from 1 to 4 without labels
  scale_x_continuous(limits = c(1, 7.1)) +
  # Set y-axis from 1 to 8 without labels
  scale_y_continuous(limits = c(1, 11.1)) +
  # Add text labels
  geom_point(data = df_sphere, aes(x = x, y = y, color = color), size = 2.5) + 
  scale_color_identity() + #use specified colors
  annotate("text", x = 2, y = 11.1, label = "71 teams independently used the same dataset to test a single\nhypothesis: that immigration reduces support for social policies", hjust = 0, size = 3.1, color = "grey30", vjust = 1, fontfact = "italic") +
  annotate("text", x = 2, y = 8.9, label = "They were asked prior to their research tasks if immigration\nlaws in their country should be made stronger or more relaxed", hjust = 0,  vjust = 0.8, size = 3.1, color = "grey30", fontface = "italic") +
  annotate("text", x = 3, y = 5, label = "Political ideology", hjust = 1, vjust = 0, size = 3.5) +
  annotate("text", x = 1.2, y = 10.62, hjust = 0, label = expression(H[1]), size = 7) +
  # lines
  geom_segment(aes(x = 1.2, y = 7.5, xend = 7, yend = 7.5), linetype = "dashed", color = "grey30", size = 0.3) +
  geom_segment(aes(x = 1.5, y = 4.6, xend = 7, yend = 4.6), size = 0.3) +

  annotate("text", x = 3, y = 2, label = "Pro-immigration", hjust = 1, color = colors[3], size = 3.5) +
  annotate("text", x = 3, y = 3, label = "Moderate", hjust = 1, color = colors[2], size = 3.5) +
  annotate("text", x = 3, y = 4, label = "Anti-immigration", hjust = 1, color = colors[1], size = 3.5) +
  annotate("text", x = 3, y = 1, label = "Total", hjust = 1, size = 3.5) +
  
  # Add the current annotations, shifted to x = 2, 3, 4 at y = 5
  annotate("text", x = 4, y = 5, label = "# of\nteams", vjust = 0, size = 3.5) +
  annotate("text", x = 4.8, y = 5, label = "Mean\nAME",  vjust = 0, size = 3.5) +
  annotate("text", x = 6.175, y = 5.65, label = "Extreme 10%\nsig effects",  vjust = 0, size = 3.5) +
  annotate("text", x = 5.75, y = 5, label = "Negative",  vjust = 0, size = 3.5) +
  annotate("text", x = 6.6, y = 5, label = "Positive",  vjust = 0, size = 3.5) +
  # Add results from Tbl1 weighted
  mapply(function(txt, x, y) {
    annotate("text", x = x, y = y, label = txt)
  }, Table_1_model[1:4,2], x_positions, y_pos1) +
  mapply(function(txt, x, y) {
    annotate("text", x = x, y = y, label = txt, color = colors[1])}, 
    Table_1_model[1:4,3], x_positions, y_pos4) +
  mapply(function(txt, x, y) {
    annotate("text", x = x, y = y, label = txt, color = colors[2])}, 
    Table_1_model[1:4,4], x_positions, y_pos3) +
  mapply(function(txt, x, y) {
    annotate("text", x = x, y = y, label = txt, color = colors[3])}, 
    Table_1_model[1:4,5], x_positions, y_pos2) +
  
  # Remove axis lines, ticks, and grid
  theme_void() +
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    plot.margin = margin(t = 20, r = 80, b = 20, l = -10),
    legend.position = "none" # Increased left margin
  ) +
  coord_cartesian(clip = "off")
f1a

dev.off()

include_graphics(here("results", "Fig1A.png"))
```

## Fig1B

```{r fig1b}
agg_png(here("results", "Fig1B.png"), res = 144, width = 600, height = 500)
# create scaling axis
custom_y_trans <- trans_new(
  name = "split_scale",
  transform = function(x) ifelse(x <= 1, x / 2, (x - 1) / (35 - 1) * 0.5 + 0.5),  # Compress 0-1 to lower half, >1 to upper half
  inverse = function(x) ifelse(x <= 0.5, x * 2, (x - 0.5) * (35 - 1) / 0.5 + 1)  # Inverse of the transform
)


f1b <- df %>%
  #subset(index != 2) %>%
  ggplot() +
  
  # First density for index2, excluding NA values
  geom_density(data = df %>% filter(!is.na(index2)),
               aes(x = AME, group = index2, fill = factor(index2)), color = NA,  
               alpha = 0.3, adjust = 7, position = "identity") +
  
  # Second density for index1, excluding NA values
  geom_density(data = df %>% filter(!is.na(index1)),
               aes(x = AME, group = index1, color = factor(index1)), 
               alpha = 1, adjust = 6, position = "identity") +  
  # Labels
  labs(x = "AME", y = "Density", title = "", fill = "Index Group", color = "Index Group") +
  
  # Manual color and fill scales
  scale_color_manual(values = colors[c(3,1)]) +   # Color for index1 groups
  scale_fill_manual(values = c("white", colors[2])) +  
  #geom_vline(xintercept = mean(df$AME[df$index == 2]), linetype = "dashed", color = "#2D708EFF") +
  #geom_vline(xintercept = mean(df$AME[df$index == 1]), linetype = "dashed", color = "#453781FF") +
  #geom_vline(xintercept = mean(df$AME[df$index == 3]), linetype = "dashed", color = "#3CBB75FF") +
  annotate("text", x = -0.45, y = 0.8, label = "Anti-immigration\nteams", hjust = 0, color = colors[1], size = 3) +
  geom_segment(x = -0.4, y = 0.35, xend = -0.4, yend = 0.12,
               arrow = arrow(type = "closed", length = unit(0.05, "inches"), angle = 15),
               color = colors[1], size = 0.06) +
    geom_segment(x = -0.37, y = 0.35, xend = -0.195, yend = 0.26,
               arrow = arrow(type = "closed", length = unit(0.05, "inches"), angle = 15),
               color = colors[1], size = 0.06) +
  annotate("text", x = 0.42, y = 0.8, label = "Pro-immigration\nteams", hjust = 1, color = colors[3], size = 3) +
  geom_segment(x = 0.37, y = 0.35, xend = 0.31, yend = 0.1,
               arrow = arrow(type = "closed", length = unit(0.05, "inches"), angle = 15),
               color = colors[3], size = 0.06) +
  theme_classic() +
    geom_segment(x = 0.35, y = 0.35, xend = 0.17, yend = 0.18,
               arrow = arrow(type = "closed", length = unit(0.05, "inches"), angle = 15),
               color = colors[3], size = 0.06, linetype = "longdash") +
    annotate("text", x = -0.01, y = 0.25, label = "Moderate\nteams", color = colors[2], size = 3) +
  geom_hline(yintercept = 1, size = 0.25, linetype = "dashed", color = "grey30") +
  theme_classic() +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 6),
        axis.text.y = element_text(size = 6),
        axis.title = element_text(size = 8)) +
  scale_y_continuous(trans = custom_y_trans, breaks = c(0, 0.25, 0.5, 0.75, 1, 3, 5, 7, 9)) +
  coord_cartesian(xlim = c(-0.45, 0.45))
f1b
dev.off()

knitr::include_graphics(here("results", "Fig1B.png"))

```
### Density under curve

```{r denscalc}
# Create a density object for the AME data
density_obj <- density(df$AME)

# Range in plot
in_range <- density_obj$x >= -0.45 & density_obj$x <= 0.45

# Calculate the area within this range using trapezoidal rule approximation
dx <- diff(density_obj$x) # Differences between consecutive x values
area_in_range <- sum(density_obj$y[in_range][-1] * dx[in_range[-1]])

# Since the total area under the density curve is 1, calculate the percentage shown
percentage_shown <- area_in_range * 100

percentage_shown
```


## Fig 2

### ATE

#### Data & Predict


```{r coefplot}
df_group1 <- df %>%
  mutate(group1 = 1,
         group3 = 0)

df_group2 <- df %>%
  mutate(group1 = 0,
         group3 = 0)

df_group3 <- df %>%
  mutate(group1 = 0,
         group3 = 1)

df_dyad_group1 <- df_dyad %>%
  mutate(indiv1 = 1,
         indiv3 = 0) %>%
  subset(!is.na(AME))

df_dyad_group2 <- df_dyad %>%
  mutate(indiv1 = 0,
         indiv3 = 0) %>%
  subset(!is.na(AME))

df_dyad_group3 <- df_dyad %>%
  mutate(indiv1 = 0,
         indiv3 = 1) %>%
  subset(!is.na(AME))

# average treatment effects
df$ate_group1_m_3 <- predict(m_3lm, newdata = df_group1)
df$ate_group2_m_3 <- predict(m_3lm, newdata = df_group2)
df$ate_group3_m_3 <- predict(m_3lm, newdata = df_group3)

df_dyad$ate_group1_m_3 <- predict(m_3dlm, newdata = df_dyad_group1)
df_dyad$ate_group2_m_3 <- predict(m_3dlm, newdata = df_dyad_group2)
df_dyad$ate_group3_m_3 <- predict(m_3dlm, newdata = df_dyad_group3)

df$ate_group1_p_3 <- predict(p_3lm, newdata = df_group1)
df$ate_group2_p_3 <- predict(p_3lm, newdata = df_group2)
df$ate_group3_p_3 <- predict(p_3lm, newdata = df_group3)

df_dyad$ate_group1_p_3 <- predict(p_3dlm, newdata = df_dyad_group1)
df_dyad$ate_group2_p_3 <- predict(p_3dlm, newdata = df_dyad_group2)
df_dyad$ate_group3_p_3 <- predict(p_3dlm, newdata = df_dyad_group3)

```

#### Weigthed Tendencies

```{r ateweight}
weighted_mean_ate_group1 <- sum(df$ate_group1_m_3 * df$mweight) / sum(df$mweight)
weighted_mean_ate_group2 <- sum(df$ate_group2_m_3 * df$mweight) / sum(df$mweight)
weighted_mean_ate_group3 <- sum(df$ate_group3_m_3 * df$mweight) / sum(df$mweight)

weighted_mean_ate_group1_dyad <- sum(df_dyad$ate_group1_m_3 * df_dyad$mweight, na.rm = T) / sum(df_dyad$mweight, na.rm = T)
weighted_mean_ate_group2_dyad <- sum(df_dyad$ate_group2_m_3 * df_dyad$mweight, na.rm = T) / sum(df_dyad$mweight, na.rm = T)
weighted_mean_ate_group3_dyad <- sum(df_dyad$ate_group3_m_3 * df_dyad$mweight, na.rm = T) / sum(df_dyad$mweight, na.rm = T)

weighted_mean_ate_group1p <- sum(df$ate_group1_p_3 * df$peerweight) / sum(df$peerweight)
weighted_mean_ate_group2p <- sum(df$ate_group2_p_3 * df$peerweight) / sum(df$peerweight)
weighted_mean_ate_group3p <- sum(df$ate_group3_p_3 * df$peerweight) / sum(df$peerweight)

weighted_mean_ate_group1p_dyad <- sum(df_dyad$ate_group1_p_3 * df_dyad$peerweight, na.rm = T) / sum(df_dyad$peerweight, na.rm = T)
weighted_mean_ate_group2p_dyad <- sum(df_dyad$ate_group2_p_3 * df_dyad$peerweight, na.rm = T) / sum(df_dyad$peerweight, na.rm = T)
weighted_mean_ate_group3p_dyad <- sum(df_dyad$ate_group3_p_3 * df_dyad$peerweight, na.rm = T) / sum(df_dyad$peerweight, na.rm = T)

# Calculate weighted variance
weighted_var_ate_group1 <- sum(df$mweight * (df$ate_group1_m_3 - weighted_mean_ate_group1)^2) / sum(df$mweight)
weighted_var_ate_group2 <- sum(df$mweight * (df$ate_group2_m_3 - weighted_mean_ate_group2)^2) / sum(df$mweight)
weighted_var_ate_group3 <- sum(df$mweight * (df$ate_group3_m_3 - weighted_mean_ate_group3)^2) / sum(df$mweight)

weighted_var_ate_group1_dyad <- sum(df_dyad$mweight * (df_dyad$ate_group1_m_3 - weighted_mean_ate_group1_dyad)^2, na.rm = T) / sum(df_dyad$mweight, na.rm = T)
weighted_var_ate_group2_dyad <- sum(df_dyad$mweight * (df_dyad$ate_group2_m_3 - weighted_mean_ate_group2_dyad)^2, na.rm = T) / sum(df_dyad$mweight, na.rm = T)
weighted_var_ate_group3_dyad <- sum(df_dyad$mweight * (df_dyad$ate_group3_m_3 - weighted_mean_ate_group3_dyad)^2, na.rm = T) / sum(df_dyad$mweight, na.rm = T)

weighted_var_ate_group1p <- sum(df$peerweight * (df$ate_group1_p_3 - weighted_mean_ate_group1p)^2) / sum(df$peerweight)
weighted_var_ate_group2p <- sum(df$peerweight * (df$ate_group2_p_3 - weighted_mean_ate_group2p)^2) / sum(df$peerweight)
weighted_var_ate_group3p <- sum(df$peerweight * (df$ate_group3_p_3 - weighted_mean_ate_group3p)^2) / sum(df$peerweight)

weighted_var_ate_group1p_dyad <- sum(df_dyad$peerweight * (df_dyad$ate_group1_p_3 - weighted_mean_ate_group1p_dyad)^2, na.rm = T) / sum(df_dyad$peerweight, na.rm = T)
weighted_var_ate_group2p_dyad <- sum(df_dyad$peerweight * (df_dyad$ate_group2_p_3 - weighted_mean_ate_group2p_dyad)^2, na.rm = T) / sum(df_dyad$peerweight, na.rm = T)
weighted_var_ate_group3p_dyad <- sum(df_dyad$peerweight * (df_dyad$ate_group3_p_3 - weighted_mean_ate_group3p_dyad)^2, na.rm = T) / sum(df_dyad$peerweight, na.rm = T)


# Calculate weighted standard error (sqrt of weighted variance divided by sample size)
weighted_se_ate_group1 <- sqrt(weighted_var_ate_group1 / sum(df$mweight))
weighted_se_ate_group2 <- sqrt(weighted_var_ate_group2 / sum(df$mweight))
weighted_se_ate_group3 <- sqrt(weighted_var_ate_group3 / sum(df$mweight))

weighted_se_ate_group1_dyad <- sqrt(weighted_var_ate_group1_dyad / sum(df_dyad$mweight, na.rm = T))
weighted_se_ate_group2_dyad <- sqrt(weighted_var_ate_group2_dyad / sum(df_dyad$mweight, na.rm = T))
weighted_se_ate_group3_dyad <- sqrt(weighted_var_ate_group3_dyad / sum(df_dyad$mweight, na.rm = T))

weighted_se_ate_group1p <- sqrt(weighted_var_ate_group1p / sum(df$peerweight))
weighted_se_ate_group2p <- sqrt(weighted_var_ate_group2p / sum(df$peerweight))
weighted_se_ate_group3p <- sqrt(weighted_var_ate_group3p / sum(df$peerweight))

weighted_se_ate_group1p_dyad <- sqrt(weighted_var_ate_group1p_dyad / sum(df_dyad$peerweight, na.rm = T))
weighted_se_ate_group2p_dyad <- sqrt(weighted_var_ate_group2p_dyad / sum(df_dyad$peerweight, na.rm = T))
weighted_se_ate_group3p_dyad <- sqrt(weighted_var_ate_group3p_dyad / sum(df_dyad$peerweight, na.rm = T))
```

### Predicted Margins
Use regression coefficients for group1 and group3 and predicted values for group2.


```{r amecalc}
# 
df$ame_group <- predict(m_3lm, newdata = df)

df_dyad$ame_group <- predict(m_3dlm, newdata = df_dyad)


df2 <- subset(df, group2 == 1) %>%
  mutate(ame_group2_m_3 = ame_group,
         ame_group2_p_3 = ame_group)

df2_dyad <- subset(df_dyad, indiv2 == 1) %>%
  mutate(ame_group2_m_3 = ame_group,
         ame_group2_p_3 = ame_group) %>%
  subset(!is.na(ame_group))

# Weighted mean AME
weighted_mean_ame_group2m <- sum(df2$ame_group2_m_3 * df2$mweight) / sum(df2$mweight)

weighted_mean_ame_group2m_dyad <- sum(df2_dyad$ame_group2_m_3 * df2_dyad$mweight) / sum(df2_dyad$mweight)



weighted_mean_ame_group2p <- sum(df2$ame_group2_m_3 * df2$peerweight) / sum(df2$peerweight)



weighted_mean_ame_group2p_dyad <- sum(df2_dyad$ame_group2_m_3 * df2_dyad$peerweight) / sum(df2_dyad$peerweight)



weighted_var_ame_group2m <- sum(df2$mweight * (df2$ame_group2_m_3 - weighted_mean_ame_group2m)^2) / sum(df2$mweight)

weighted_var_ame_group2m_dyad <- sum(df2_dyad$mweight * (df2_dyad$ame_group2_m_3 - weighted_mean_ame_group2m_dyad)^2) / sum(df2_dyad$mweight)

weighted_var_ame_group2p <- sum(df2$peerweight * (df2$ame_group2_m_3 - weighted_mean_ame_group2p)^2) / sum(df2$peerweight)


weighted_var_ame_group2p_dyad <- sum(df2_dyad$peerweight * (df2_dyad$ame_group2_m_3 - weighted_mean_ame_group2p_dyad)^2) / sum(df2_dyad$peerweight)


weighted_se_ame_group2m <- sqrt(weighted_var_ame_group2m / sum(df2$mweight))

weighted_se_ame_group2m_dyad <- sqrt(weighted_var_ame_group2m_dyad / sum(df2_dyad$mweight))

weighted_se_ame_group2p <- sqrt(weighted_var_ame_group2p / sum(df2$peerweight))

weighted_se_ame_group2p_dyad <- sqrt(weighted_var_ame_group2p_dyad / sum(df2_dyad$peerweight))

# get coeffs
model_summary <- summary(m_3lm)
model_summaryp <- summary(p_3lm)

# Extract coefficients and standard errors for group1 and group3
coeff_group1 <- model_summary$coefficients["group1", "Estimate"]
se_group1 <- model_summary$coefficients["group1", "Std. Error"]

coeff_group3 <- model_summary$coefficients["group3", "Estimate"]
se_group3 <- model_summary$coefficients["group3", "Std. Error"]

coeff_group1p <- model_summaryp$coefficients["group1", "Estimate"]
se_group1p <- model_summaryp$coefficients["group1", "Std. Error"]

coeff_group3p <- model_summaryp$coefficients["group3", "Estimate"]
se_group3p <- model_summaryp$coefficients["group3", "Std. Error"]

model_summaryd <- summary(m_3dlm)
model_summarydp <- summary(p_3dlm)

# Extract coefficients and standard errors for group1 and group3
coeff_group1d <- model_summaryd$coefficients[grep("^indiv1$", rownames(model_summaryd$coefficients)), "Estimate"]
se_group1d <- model_summaryd$coefficients[grep("^indiv1$", rownames(model_summaryd$coefficients)), "Std. Error"]

coeff_group3d <- model_summaryd$coefficients[grep("^indiv3$", rownames(model_summaryd$coefficients)), "Estimate"]
se_group3d <- model_summaryd$coefficients[grep("^indiv3$", rownames(model_summaryd$coefficients)), "Std. Error"]

coeff_group1dp <- model_summarydp$coefficients[grep("^indiv1$", rownames(model_summarydp$coefficients)), "Estimate"]
se_group1dp <- model_summarydp$coefficients[grep("^indiv1$", rownames(model_summarydp$coefficients)), "Std. Error"]

coeff_group3dp <- model_summarydp$coefficients[grep("^indiv1$", rownames(model_summarydp$coefficients)), "Estimate"]
se_group3dp <- model_summarydp$coefficients[grep("^indiv1$", rownames(model_summarydp$coefficients)), "Std. Error"]
```

### Plotting DFs

```{r coefplot2}
plot_data_ate <- data.frame(
  group = c("group1_m", "group2_m", "group3_m", "group1_p", "group2_p", "group3_p"),
  weight = c("m", "m", "m", "p", "p", "p"),
  mean = c(weighted_mean_ate_group1, weighted_mean_ate_group2, weighted_mean_ate_group3,
           weighted_mean_ate_group1p, weighted_mean_ate_group2p, weighted_mean_ate_group3p),
  se = c(weighted_se_ate_group1, weighted_se_ate_group2, weighted_se_ate_group3,
         weighted_se_ate_group1p, weighted_se_ate_group2p, weighted_se_ate_group3p)
)

plot_data_ate_dyad <- data.frame(
  group = c("group1_m", "group2_m", "group3_m", "group1_p", "group2_p", "group3_p"),
  weight = c("m", "m", "m", "p", "p", "p"),
  mean = c(weighted_mean_ate_group1_dyad, weighted_mean_ate_group2_dyad, weighted_mean_ate_group3_dyad,
           weighted_mean_ate_group1p_dyad, weighted_mean_ate_group2p_dyad, weighted_mean_ate_group3p_dyad),
  se = c(weighted_se_ate_group1_dyad, weighted_se_ate_group2_dyad, weighted_se_ate_group3_dyad,
         weighted_se_ate_group1p_dyad, weighted_se_ate_group2p_dyad, weighted_se_ate_group3p_dyad)
)

plot_data_ame <- data.frame(
  group = c("group1_m", 
            "group2_m", 
            "group3_m", 
            "group1_p", 
            "group2_p", 
            "group3_p"),
  weight = c("m", "m", "m", "p", "p", "p"),
  mean = c(coeff_group1 + weighted_mean_ame_group2m,
           weighted_mean_ame_group2m,
           coeff_group3 + weighted_mean_ame_group2m,
           coeff_group1p + weighted_mean_ame_group2p,
           weighted_mean_ame_group2p,
           coeff_group3p + weighted_mean_ame_group2p),
  se = c(se_group1, weighted_se_ame_group2m, se_group3,
         se_group1p, weighted_se_ame_group2p, se_group3p))

plot_data_ame_dyad <- data.frame(
  group = c("group1_m", "group2_m", "group3_m", "group1_p", "group2_p", "group3_p"),
  weight = c("m", "m", "m", "p", "p", "p"),
  mean = c(coeff_group1d+weighted_mean_ame_group2m_dyad, weighted_mean_ame_group2m_dyad, coeff_group3d+weighted_mean_ame_group2m_dyad,
           coeff_group1dp+weighted_mean_ame_group2p_dyad, weighted_mean_ame_group2p_dyad, coeff_group3dp+weighted_mean_ame_group2p_dyad),
  se = c(se_group1d, weighted_se_ame_group2m_dyad, se_group3d,
         se_group1dp, weighted_se_ame_group2p_dyad, se_group3dp)
)


```

### Fig2A Model

```{r fig2a}
agg_png(here("results", "Fig2A.png"), res = 144, height = 300, width = 650)

plot_data_ame %>%
  subset(weight == "m") %>%
  ggplot(aes(x = factor(group, levels = rev(unique(group))), y = mean, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin = mean - 1.645 * se, ymax = mean + 1.645 * se), width = 0.1) +
  labs(x = "Variables", y = "Marginal Effects\n(ame, nmodel weights, model-level)", title = "") +
  #geom_hline(yintercept = 0, linetype = "dotted", color = "grey") + 
  ylim(-0.115,0.04) +
  annotate("text", y = c(coeff_group1 + weighted_mean_ame_group2m,
                         weighted_mean_ame_group2m,
                         coeff_group3 + weighted_mean_ame_group2m), 
           x = c(2.7,1.7,0.7),
           label = c("Anti-immigration", "Moderate", "Pro-immigration"),
           color = colors[1:3],
           size = 3) +
  coord_flip() +
  scale_color_manual(values = colors) +
  theme_classic() +
  theme(axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size = 8),
        axis.title.y = element_blank(),
        legend.position = "none")

dev.off()

knitr::include_graphics(here("results", "Fig2A.png"))
```

### Fig2B Model Peer

```{r fig2b}
agg_png(here("results", "Fig2B.png"), res = 144, height = 300, width = 650)

plot_data_ate %>%
  subset(weight == "m") %>%
  ggplot(aes(x = factor(group, levels = rev(unique(group))), y = mean, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin = mean - 1.645 * se, ymax = mean + 1.645 * se), width = 0.1) +
  labs(x = "Variables", y = "Average Treatment Effects\n(ame, nmodel weights, model-level)", title = "") +
  #geom_hline(yintercept = 0, linetype = "dotted", color = "grey") + 
  ylim(-0.115,0.04) +
  annotate("text", y = c(weighted_mean_ate_group1,
                         weighted_mean_ate_group2,
                         weighted_mean_ate_group3), 
           x = c(2.7,1.7,0.7),
           label = c("Anti-immigration", "Moderate", "Pro-immigration"),
           color = colors[1:3],
           size = 3) +
  coord_flip() +
  scale_color_manual(values = colors) +
  theme_classic() +
  theme(axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size = 8),
        axis.title.y = element_blank(),
        legend.position = "none")


dev.off()

knitr::include_graphics(here("results", "Fig2B.png"))
```

### Fig2C Dyad

```{r fig2c}
agg_png(here("results", "Fig2C.png"), res = 144, height = 300, width = 650)

plot_data_ame_dyad %>%
  subset(weight == "m") %>%
  ggplot(aes(x = factor(group, levels = rev(unique(group))), y = mean, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin = mean - 1.645 * se, ymax = mean + 1.645 * se), width = 0.1) +
  labs(x = "Variables", y = "Marginal Effects\n(ame, nmodel weights, indiv-model level)", title = "") +
  #geom_hline(yintercept = 0, linetype = "dotted", color = "grey") + 
  ylim(-0.075,0.025) +
  annotate("text", y = c(coeff_group1d + weighted_mean_ame_group2m_dyad,
                         weighted_mean_ame_group2m_dyad,
                         coeff_group3d + weighted_mean_ame_group2m_dyad), 
           x = c(2.7,1.7,0.7),
           label = c("Anti-immigration", "Moderate", "Pro-immigration"),
           color = colors[1:3],
           size = 3) +
  coord_flip() +
  scale_color_manual(values = colors) +
  theme_classic() +
  theme(axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size = 8),
        axis.title.y = element_blank(),
        legend.position = "none")

dev.off()

knitr::include_graphics(here("results", "Fig2C.png"))
```

### Fig2D Dyad Peer

```{r fig2d}
agg_png(here("results", "Fig2D.png"), res = 144, height = 300, width = 650)

plot_data_ate_dyad %>%
  subset(weight == "m") %>%
  ggplot(aes(x = factor(group, levels = rev(unique(group))), y = mean, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin = mean - 1.645 * se, ymax = mean + 1.645 * se), width = 0.1) +
  labs(x = "Variables", y = "Average Treatment Effects\n(ame, nmodel weights, indiv-model level)", title = "") +
  #geom_hline(yintercept = 0, linetype = "dotted", color = "grey") + 
  ylim(-0.075,0.025) +
  annotate("text", y = c(weighted_mean_ate_group1_dyad,
                         weighted_mean_ate_group2_dyad,
                         weighted_mean_ate_group3_dyad), 
           x = c(2.7,1.7,0.7),
           label = c("Anti-immigration", "Moderate", "Pro-immigration"),
           color = colors[1:3],
           size = 3) +
  coord_flip() +
  scale_color_manual(values = colors) +
  theme_classic() +
  theme(axis.line.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size = 8),
        axis.title.y = element_blank(),
        legend.position = "none")


dev.off()

knitr::include_graphics(here("results", "Fig2D.png"))
```







```{r plotdist1}

# Number of points for smoothness of the normal distribution plot
n_points <- 100

# Generate data for normal distributions based on coefficients and standard errors
coef_df <- coef_df %>%
  rowwise() %>%
  mutate(
    x_dist = list(seq(estimate - 1.645 * std.error, estimate + 1.645 * std.error, length.out = n_points)),
    y_dist = list(dnorm(x_dist, mean = estimate, sd = std.error))
  )

# Unnest the distributions for plotting
coef_dist <- coef_df %>%
  unnest(c(x_dist, y_dist))

# Scale the y_dist (densities) so that they all have the same maximum height
coef_dist <- coef_dist %>%
  group_by(term) %>%
  mutate(y_dist_scaled = y_dist / max(y_dist))  # Scale so all max heights are the same

# Add a y-axis position for each coefficient (1 through 5)
coef_dist <- coef_dist %>%
  mutate(term_position = case_match(term,
                                    "Prior knowledge\nof this topic" ~ 1,
                                  "Statistics and\nsoftware skills" ~ 2,
                                  "Pro-\nimmigration" ~ 3,
                                  "Moderate" ~ 4,
                                  "Anti-\nimmigration" ~ 5))

# Define the viridis color palette for the histograms
colors <- viridis_pal()(length(unique(coef_dist$term)))


```


```{r plotdist}
# Create the plot
ggplot(coef_dist, aes(x = x_dist, y = term_position, group = term)) +
  # Plot the normal distributions as smooth curves using geom_ribbon
  geom_ribbon(aes(ymin = term_position - 0.2, ymax = term_position + y_dist_scaled * 0.5 - 0.2, fill = term), alpha = 0.8) +
  scale_fill_manual(values = colors) +
  # Add a vertical line at x = 0 to mark the baseline
  geom_vline(xintercept = 0, linetype = "dotted", color = "grey") +
  # Plot standardized coefficient labels next to the distributions
  geom_text(data = coef_filtered %>%
              left_join(coef_dist %>% group_by(term) %>% summarize(term_position = first(term_position)), by = "term"),
            aes(x = estimate, y = term_position + 0.5, label = format(round(std_estimate, 2), nsmall = 2)),
            vjust = 1.5, hjust = -0.7, color = "grey15", size = 3) +
  # Labels and formatting
  labs(x = "Regression Coefficients", y = "", title = "") +
  theme_classic() +
  theme(axis.text.y = element_text(hjust = 1, size = 10),
        axis.title.x = element_text(size = 12),
        legend.position = "none") +
  scale_y_continuous(breaks = 1:length(unique(coef_dist$term)), labels = c("Prior knowledge\nof this topic","Statistics and\nsoftware skills", "Pro-\nimmigration", "Moderate", "Anti-\nimmigration"))

```

## 58 Categories

### Create
Create unique combinations of variables

```{r the58}
df_stata <- df_stata %>%
  mutate(unique_combo = paste(scale, stock, flow, level_cyear, allavailable, w1996, w2006, w2016, sep = "_")) %>%
  mutate(indicator = as.numeric(factor(unique_combo)))

df_stata <- df_stata %>%
  # Group by the unique combination
  group_by(unique_combo) %>%
  # Calculate the mean of 'ame' for each unique combination and create a new variable 'ame_combo_mean'
  mutate(ame_combo_mean = mean(ame, na.rm = TRUE)) %>%
  ungroup()
```


### Plot

```{r the58plot}

# Cap the count at 50
df_summary <- df_stata %>%
  group_by(unique_combo, index) %>%
  summarise(count = n(), ame_combo_mean = mean(ame, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(count = pmin(count, 25))  # Cap the count at 50

# Order unique_combo by ame_combo_mean
df_summary <- df_summary %>%
  arrange(ame_combo_mean) %>%
  mutate(unique_combo = factor(unique_combo, levels = unique(unique_combo)))

# Create the heatmap
ggplot(df_summary, aes(x = unique_combo, y = index, fill = count)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "steelblue") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = "Model Combinations", y = "Index Group", fill = "Count (Capped at 25)", 
       title = "Heatmap of Model Combinations by Group (Capped at 25)")

```


```{r dens58}
df_stata <- df_stata %>%
  arrange(ame_combo_mean) %>%
  mutate(unique_combo_numeric = as.integer(factor(unique_combo, levels = unique(unique_combo))))

# Step 2: Calculate the density for each index group and adjust y-axis positions to avoid overlap
# Define offsets for each index group (adjust these values as needed)
offsets <- c(0.2, 0, -0.2)  # Offset for index == 1, index == 2, and index == 3
```


```{r dens58p}

agg_png(here("results", "Fig5.png"), res = 144, height = 550, width = 700 )

viridis_colors <- viridis_pal()(5)  # Get 2 colors from the viridis palette
color_index_1 <- viridis_colors[1]  # Color for index == 1
color_index_2 <- viridis_colors[4]


# Step 3: Plot using geom_density with the offset
df_stata %>%
  subset(index != 2) %>%
ggplot(aes(x = unique_combo_numeric, group = index, color = factor(index), fill = factor(index))) +
  geom_density( alpha = 0.5, adjust = 0.5, position = "identity") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = "Unique Model Specifications\nOrdered by Average AME", 
       y = "Density", 
       title = "",
       fill = "Index Group", color = "Index Group") +
  scale_x_continuous(breaks = 1:58)  +
  annotate("text", x = 1, y = 0.044, label = "Anti-immigration teams\ntended to select\nunique specifications\nproducing negative\nresults", size = 3, color = color_index_1, hjust = 0) +
  annotate("text", x = 58, y = 0.044, label = "Pro-immigration teams\ntended to select\nunique specifications\nproducing positive\nresults", size = 3, color = color_index_2, hjust = 1) +
  scale_color_manual(values = c(color_index_1, color_index_2)) +
  scale_fill_manual(values = c(color_index_1, color_index_2)) +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")

dev.off()

knitr::include_graphics(here("results", "Fig5.png"))

```







## Old stuff

### Hist

```{r h}
agg_png(here::here("results", "Fig1.png"), res = 144, width = 600, height = 550)

ggplot(df, aes(y = AME)) +
  geom_violin(
    aes(x = factor(index), fill = index)
  ) +
  stat_summary(
    aes(x = index-0.13, fill= index),
    fun = mean, color = "grey40",
  ) +
  stat_summary(
    aes(x = index-0.13, fill= index),
    fun.data = mean_sdl, fun.args = list(mult = 1),
    geom = "errorbar", color = "grey40",
    width = 0.2,
  ) +
  annotate("text", label = round(mean(df$AME[df$index == 1]), 3), 
           x = 1.2, y = .07, 
           color = "grey40", size = 3) +
  annotate("text", label = expression(italic("means:")), 
           x= 1.2, y = .13, 
           color = "grey40", size = 3) +
  annotate("text", label = format(round(mean(df$AME[df$index == 2]), 3), nsmall = 3),
           x = 2.2, y = .07, 
           color = "grey40", size = 3) +
  annotate("text", label = format(round(mean(df$AME[df$index == 3]), 3), nsmall = 3),
           x = 3.2, y = .07, 
           color = "grey40", size = 3) +
  scale_fill_viridis(begin = 0.2) +
  coord_cartesian(ylim = c(-0.4,0.4)) +
  scale_x_discrete(labels = c("1" = "Anti-imm",
                              "2" = "Moderate",
                              "3" = "Pro-imm")) +
  theme_classic() +
  theme(
    legend.position = "none",
    axis.title.x = element_blank()
  )
  
dev.off()

knitr::include_graphics(here::here("results", "Fig1.png"))

```

```{r ridges}
ggplot(df, aes(x = AME, fill = factor(index), y = factor(index))) +
  geom_density_ridges2() +
  coord_cartesian(xlim = c(-0.5,0.5)) +
  theme_classic()
  
```
### Adj Mean Differences




### Predicted values at means

```{r meanadj}
# Step 1: Calculate means of the variables to be fixed
mean_stats_brw <- mean(df$stats_brw, na.rm = TRUE)
mean_topic_brw <- mean(df$topic_brw, na.rm = TRUE)
mean_t2 <- mean(df$t2, na.rm = TRUE)
mean_t3 <- mean(df$t3, na.rm = TRUE)
mean_mdegree <- mean(as.numeric(df$mdegree), na.rm = TRUE)
mean_pbelief <- mean(as.numeric(df$pbelief), na.rm = TRUE)

# Step 2: Create a new dataset for prediction
# Keep group1 and group3 at their actual values, and others at their means
new_data <- data.frame(
  group1 = df$group1,
  group3 = df$group3,
  stats_brw = mean_stats_brw,
  topic_brw = mean_topic_brw,
  t2 = mean_t2,
  t3 = mean_t3,
  pbelief = mean_pbelief,
  index = df$index,
  mdegree = 1)

# Step 3: Predict using the new data
df$AME_hat <- predict(m_4, newdata = new_data)

#mean center, as it has no natural metric
df$AME_hat = df$AME_hat - mean(df$AME_hat)

```

### Viz

```{r fig1viz}
set.seed(90211)

df %>%
  mutate(AME_hat = AME_hat + rnorm(n(), mean = 0, sd = 0.01)) %>%
  ggplot(aes(x = AME_hat, fill = factor(index), y = factor(index))) +
  #geom_density_ridges2(height = "density") +
  geom_density_ridges2(
                       rel_min_height = 0.005, 
                       scale = 1, 
                       stat = "density", 
                       #bw = 0.05,
                       aes(height = after_stat(density))) +
  scale_fill_viridis_d() +
  coord_cartesian(xlim = c(-0.2,0.2)) +
  theme_classic()

```

```{r ha}
agg_png(here::here("results", "Fig1adj.png"), res = 144, width = 600, height = 550)

ggplot(df, aes(y = AME_hat)) +
  geom_violin(
    aes(x = factor(index), fill = index)
  ) +
  stat_summary(
    aes(x = index-0.13, fill= index),
    fun = mean, color = "grey40",
  ) +
  stat_summary(
    aes(x = index-0.13, fill= index),
    fun.data = mean_sdl, fun.args = list(mult = 1),
    geom = "errorbar", color = "grey40",
    width = 0.2,
  ) +
  annotate("text", label = round(mean(df$AME_hat[df$index == 1]), 3), 
           x = 1.2, y = .07, 
           color = "grey40", size = 3) +
  annotate("text", label = expression(italic("means:")), 
           x= 1.2, y = .13, 
           color = "grey40", size = 3) +
  annotate("text", label = format(round(mean(df$AME_hat[df$index == 2]), 3), nsmall = 3),
           x = 2.2, y = .07, 
           color = "grey40", size = 3) +
  annotate("text", label = format(round(mean(df$AME_hat[df$index == 3]), 3), nsmall = 3),
           x = 3.2, y = .07, 
           color = "grey40", size = 3) +
  scale_fill_viridis(begin = 0.2) +
  ylim(-0.2,0.2) +
  scale_x_discrete(labels = c("1" = "Anti-imm",
                              "2" = "Moderate",
                              "3" = "Pro-imm")) +
  theme_classic() +
  theme(
    legend.position = "none",
    axis.title.x = element_blank()
  )
  
dev.off()

knitr::include_graphics(here::here("results", "Fig1adj.png"))

```


